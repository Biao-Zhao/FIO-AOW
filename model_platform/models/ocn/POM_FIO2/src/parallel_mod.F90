!=======================================================================
!CVS $Id: parallel_mod.F90,v 1.3 2013/06/21 07:22:01 wgs Exp $
!CVS $Source: /soa04/users/wgs/.mycvsroot/intercomm/ocean/parallel_mod.F90,v $
!CVS $Name:  $
!=======================================================================
MODULE parallel_mod
   use data_kind_mod
   USE LIMS, ONLY : NUMXCPU,NUMYCPU,MYID,NPROCS,IM,JM,KB
   USE CONTROL, ONLY : ISLON,IELON,ISLAT,IELAT,MSR,          &
                       IUP,IDOWN,ILEFT,IRIGHT,NEIGHBOR,I,J,NEIGHBOR_ID
   USE CONST
   USE ALL_VAR
   implicit none
   include 'mpif.h'
!-----------------------------------------------------------------------
!
!     module variables
!
!-----------------------------------------------------------------------
   PUBLIC PAR_INIT,PAR_END,BARRIER,MYPE,NPES,SET_MPI_ENV,    &
          GATHER_INT,BCAST_INT,EXTREMUM,COMM_2D,COMM_3D,     &
          COMM_INTERNAL_MODE,COMM_EXTERNAL_MODE,COMPTEST
   INTEGER,PUBLIC :: pom_mpi_comm
   PRIVATE
!***********************************************************************   
   INTERFACE EXTREMUM 
   Module Procedure EXTREM_0D,EXTREM_1D,EXTREM_2D,EXTREM_3D,EXTREM_4D
   END INTERFACE EXTREMUM 
!***********************************************************************   
   INTEGER(kind_in),PRIVATE :: IERR
   INTEGER STATUS(MPI_STATUS_SIZE)
!***********************************************************************   
   CONTAINS
!***********************************************************************
!  Support routines for machines that support MPI
!  Initialise Parallel environment
   SUBROUTINE PAR_INIT
   IMPLICIT NONE
   IF(POM_MPI_COMM.EQ.-1)THEN
   CALL MPI_INIT(IERR)
        POM_MPI_COMM=MPI_COMM_WORLD
   END IF
   RETURN
   END SUBROUTINE

!************************************************************************
!  Shut down Parallel environment
   SUBROUTINE PAR_END
   IMPLICIT NONE
   CALL MPI_FINALIZE(IERR)
   RETURN
   END SUBROUTINE
!************************************************************************
!
!  These two functions are much used in the code
!
   INTEGER(kind_in) FUNCTION MYPE()
   IMPLICIT NONE
   INTEGER(kind_in) TMP
   CALL MPI_COMM_RANK(pom_mpi_comm,TMP,IERR)
   MYPE = TMP
   RETURN
   END FUNCTION
!************************************************************************
   INTEGER(kind_in) FUNCTION NPES()
   IMPLICIT NONE
   INTEGER(kind_in) TMP
   CALL MPI_COMM_SIZE(pom_mpi_comm,TMP,IERR)
   NPES = TMP
   RETURN
   END FUNCTION
!************************************************************************
   SUBROUTINE BARRIER()
   IMPLICIT NONE
   CALL MPI_BARRIER(pom_mpi_comm,IERR)
   RETURN
   END SUBROUTINE
!************************************************************************
   SUBROUTINE SET_MPI_ENV(MYID,NPROCS,SERIAL,PAR,MSR)
   IMPLICIT NONE
   INTEGER, INTENT(OUT) :: MYID,NPROCS
   LOGICAL, INTENT(OUT) :: SERIAL,PAR,MSR

   CALL PAR_INIT
   MYID=MYPE()
   NPROCS=NPES()

   IF(kind_r4==4)MPI_F=MPI_REAL4
   IF(kind_r4==8)MPI_F=MPI_REAL8

   IF(kind_i4==4)MPI_I=MPI_INTEGER4
   IF(kind_i4==8)MPI_I=MPI_INTEGER8

   IF(NPROCS > 1) SERIAL=.FALSE.
   IF(NPROCS > 1) PAR   =.TRUE.
   IF(MYID /=  0) MSR   =.FALSE.
   RETURN  
   END SUBROUTINE
!************************************************************************
!************************************************************************
   SUBROUTINE GATHER_INT(SBUFFER,RBUFFER)
   USE LIMS, ONLY : MYID
   USE CONTROL,ONLY : MSR
   IMPLICIT NONE
   INTEGER,DIMENSION(:) :: SBUFFER,RBUFFER
   INTEGER ROOT,COUNT
   INTEGER DIM2(1)
   DIM2=SHAPE(SBUFFER)
   COUNT=DIM2(1)
   ROOT=0
   CALL MPI_GATHER(SBUFFER,COUNT,MPI_INTEGER,RBUFFER,COUNT,   &
                   MPI_INTEGER,ROOT,pom_mpi_comm,IERR)
   END SUBROUTINE
!************************************************************************
   SUBROUTINE BCAST_INT(BUFF)
   IMPLICIT NONE
   INTEGER BUFF(:,:)
   INTEGER COUNT,ROOT,DIM2(2)

   DIM2=SHAPE(BUFF)
   COUNT = DIM2(1)*DIM2(2) 
   ROOT = 0 
   CALL MPI_BCAST(BUFF,COUNT,MPI_INTEGER,ROOT,pom_mpi_comm,IERR)
   END SUBROUTINE
!************************************************************************
   SUBROUTINE BCAST_REAL(BUFF)
   IMPLICIT NONE
   REAL BUFF
   INTEGER COUNT,ROOT

   COUNT = 1
   ROOT = 0
   CALL MPI_BCAST(BUFF,COUNT,MPI_REAL,ROOT,pom_mpi_comm,IERR)
   END SUBROUTINE
!************************************************************************
   FUNCTION EXTREM_0D(VAR,OPC)
   IMPLICIT NONE
   REAL(kind_r4),INTENT(IN) :: VAR
   REAL(kind_r4) :: EXTREM_0D
   CHARACTER(LEN=*),OPTIONAL :: OPC
!  LOCAL
   INTEGER MASTER,OP,L1,L2
   REAL(kind_r4) :: MAXV
   MASTER=0;OP=MPI_MAX

   IF(PRESENT(OPC))THEN
   L1=0;L2=0
   L1=INDEX(OPC,"MIN")
   L2=INDEX(OPC,"min")
   IF(L1/=0.OR.L2/=0)OP=MPI_MIN
   END IF

   CALL MPI_REDUCE(VAR,MAXV,1,MPI_REAL,OP,MASTER,pom_mpi_comm,IERR)
   EXTREM_0D=MAXV
   RETURN
   END FUNCTION EXTREM_0D
!  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   FUNCTION EXTREM_1D(VAR,OPC,FIJK)
   IMPLICIT NONE
   REAL(kind_r4),INTENT(IN),DIMENSION(:) :: VAR
   REAL(kind_r4) :: EXTREM_1D
   CHARACTER(LEN=*),OPTIONAL :: OPC,FIJK
!  LOCAL
   INTEGER MASTER,OP,L1,L2
   REAL(kind_r4) :: MAXV,GMAX
   INTEGER NDIM(1)
   MASTER=0;OP=MPI_MAX
   MAXV=MAXVAL(VAR)
   NDIM=MAXLOC(VAR)

   IF(PRESENT(OPC))THEN
   L1=0;L2=0
   L1=INDEX(OPC,"MIN")
   L2=INDEX(OPC,"min")
   IF(L1/=0.OR.L2/=0)THEN
   OP=MPI_MIN
   MAXV=MINVAL(VAR)
   NDIM=MINLOC(VAR)
   END IF
   END IF
   CALL MPI_REDUCE(MAXV,GMAX,1,MPI_REAL,OP,MASTER,pom_mpi_comm,IERR)

   IF(PRESENT(FIJK))THEN
   CALL BCAST_REAL(GMAX)
   IF(GMAX==MAXV)THEN
!    WRITE(6,*),MYID,TRIM(OPC),"The Value = ",VAR(NDIM(1)),NDIM,MAXV
   END IF
   END IF

   EXTREM_1D=GMAX
   RETURN
   END FUNCTION EXTREM_1D
!  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   FUNCTION EXTREM_2D(VAR,OPC,FIJK)
   IMPLICIT NONE
   REAL(kind_r4),INTENT(IN),DIMENSION(:,:) :: VAR
   REAL(kind_r4) :: EXTREM_2D
   CHARACTER(LEN=*),OPTIONAL :: OPC,FIJK
!  LOCAL
   INTEGER MASTER,OP,L1,L2
   INTEGER NDIM(2)
   REAL(kind_r4) :: MAXV,GMAX
   MASTER=0;OP=MPI_MAX
   MAXV=MAXVAL(VAR)
   NDIM=MAXLOC(VAR)

   IF(PRESENT(OPC))THEN
   L1=0;L2=0
   L1=INDEX(OPC,"MIN")
   L2=INDEX(OPC,"min")
   IF(L1/=0.OR.L2/=0)THEN
   OP=MPI_MIN
   MAXV=MINVAL(VAR)
   NDIM=MINLOC(VAR)
   END IF
   END IF
   CALL MPI_REDUCE(MAXV,GMAX,1,MPI_REAL,OP,MASTER,pom_mpi_comm,IERR)
   IF(PRESENT(FIJK))THEN
   CALL BCAST_REAL(GMAX)
   IF(GMAX==MAXV)THEN
!     WRITE(6,*),MYID,TRIM(OPC),"The Value = ",VAR(NDIM(1),NDIM(2)),MAXV
!     WRITE(6,*),MYID,TRIM(OPC),"I= ",NDIM(1)+ISLON-1,"J= ",NDIM(2)+ISLAT-1
!      WRITE(6,*),MYID,TRIM(OPC),"topo =",h(NDIM(1)+ISLON-1,NDIM(2)+ISLAT-1),FSM(NDIM(1)+ISLON-1,NDIM(2)+ISLAT-1)
   END IF
   END IF
   EXTREM_2D=GMAX
   RETURN
   END FUNCTION EXTREM_2D
!  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   FUNCTION EXTREM_3D(VAR,OPC,FIJK)
   IMPLICIT NONE
   REAL(kind_r4),INTENT(IN),DIMENSION(:,:,:) :: VAR
   REAL(kind_r4) :: EXTREM_3D
   CHARACTER(LEN=*),OPTIONAL :: OPC,FIJK
!  LOCAL
   INTEGER MASTER,OP,L1,L2
   INTEGER NDIM(3)
   REAL(kind_r4) :: MAXV,GMAX
   MASTER=0;OP=MPI_MAX
   MAXV=MAXVAL(VAR)
   NDIM=MAXLOC(VAR)

   IF(PRESENT(OPC))THEN
   L1=0;L2=0
   L1=INDEX(OPC,"MIN")
   L2=INDEX(OPC,"min")
   IF(L1/=0.OR.L2/=0)THEN
   OP=MPI_MIN
   MAXV=MINVAL(VAR)
   NDIM=MINLOC(VAR)
   END IF
   END IF
   CALL MPI_REDUCE(MAXV,GMAX,1,MPI_REAL,OP,MASTER,pom_mpi_comm,IERR)
   IF(PRESENT(FIJK))THEN
   CALL BCAST_REAL(GMAX)
   IF(GMAX==VAR(NDIM(1),NDIM(2),NDIM(3)))THEN
!     WRITE(6,*),MYID,TRIM(OPC),"The Value = ",VAR(NDIM(1),NDIM(2),NDIM(3)),MAXV
!     WRITE(6,*),MYID,TRIM(OPC),"I= ",NDIM(1)+ISLON-1,"J= ",NDIM(2)+ISLAT-1
!     WRITE(6,*),MYID,TRIM(OPC),"topo =",h(NDIM(1)+ISLON-1,NDIM(2)+ISLAT-1),FSM(NDIM(1)+ISLON-1,NDIM(2)+ISLAT-1)
   END IF
   END IF
   EXTREM_3D=GMAX
   RETURN
   END FUNCTION EXTREM_3D
!  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   FUNCTION EXTREM_4D(VAR,OPC,FIJK)
   IMPLICIT NONE
   REAL(kind_r4),INTENT(IN),DIMENSION(:,:,:,:) :: VAR
   REAL(kind_r4) :: EXTREM_4D
   CHARACTER(LEN=*),OPTIONAL :: OPC
   CHARACTER(LEN=*),OPTIONAL :: FIJK
!  LOCAL
   INTEGER MASTER,OP,L1,L2
   INTEGER NDIM(4)
   REAL(kind_r4) :: MAXV,GMAX
   MASTER=0;OP=MPI_MAX
   MAXV=MAXVAL(VAR)
   NDIM=MAXLOC(VAR)

   IF(PRESENT(OPC))THEN
   L1=0;L2=0
   L1=INDEX(OPC,"MIN")
   L2=INDEX(OPC,"min")
   IF(L1/=0.OR.L2/=0)THEN
   OP=MPI_MIN
   MAXV=MINVAL(VAR)
   NDIM=MINLOC(VAR)
   END IF
   END IF
   CALL MPI_REDUCE(MAXV,GMAX,1,MPI_REAL,OP,MASTER,pom_mpi_comm,IERR)
   IF(PRESENT(FIJK))THEN
   CALL BCAST_REAL(GMAX)
   IF(GMAX==VAR(NDIM(1),NDIM(2),NDIM(3),NDIM(4))) THEN
!    WRITE(6,*),MYID,TRIM(OPC)," The Value = ",VAR(NDIM(1),NDIM(2),NDIM(3),NDIM(4)),NDIM,MAXV
   END IF
   END IF
   EXTREM_4D=GMAX
   RETURN
   END FUNCTION EXTREM_4D
!  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   SUBROUTINE COMM_2D(ARR,INDEX1,INDEX2)
   IMPLICIT NONE
   REAL ARR(ISLON-LE:IELON+LE,ISLAT-LE:IELAT+LE)
   INTEGER INDEX1,INDEX2

   IF(NUMYCPU>1)CALL UPDATE_2D_UP_BOTTOM(ARR,INDEX1)
   IF(NUMXCPU>1)CALL UPDATE_2D_LEFT_RIGHT(ARR,INDEX2)
   IF(NUMXCPU>1.AND.NUMYCPU>1)CALL UPDATE_2D_LEFTBOTTOM_RIGHTUP(ARR,INDEX2)
   END SUBROUTINE COMM_2D
!  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   SUBROUTINE UPDATE_2D_UP_BOTTOM(ARR,INDEX1)
   IMPLICIT NONE
   REAL ARR(ISLON-LE:IELON+LE,ISLAT-LE:IELAT+LE)
   INTEGER INDEX1,IND
   INTEGER MYRANK,ISIZE
   INTEGER II

   MYRANK=MOD(MYID+1,NUMYCPU)
   DO II=1,INDEX1
   IND=II-1
!  FROM BOTTOM TO UP EXCHANGE DATA
   ISIZE=IELON-ISLON+1
   IF(MYRANK==1)THEN
   CALL MPI_SEND(ARR(ISLON,IELAT-IND),ISIZE,MPI_REAL,MYID+1,10*II, pom_mpi_comm,IERR)
   ELSEIF(MYRANK==0)THEN
   CALL MPI_RECV(ARR(ISLON,ISLAT-II),ISIZE,MPI_REAL,MYID-1,10*II,pom_mpi_comm,STATUS,IERR)
   ELSE
   CALL MPI_SEND(ARR(ISLON,IELAT-IND),ISIZE,MPI_REAL,MYID+1,10*II,pom_mpi_comm,IERR)
   CALL MPI_RECV(ARR(ISLON,ISLAT-II),ISIZE,MPI_REAL,MYID-1,10*II,pom_mpi_comm,STATUS,IERR)
   END IF
!  FROM UP TO BOTTOM EXCHANGE DATA
   IF(MYRANK==1)THEN
   CALL MPI_RECV(ARR(ISLON,IELAT+II),ISIZE,MPI_REAL,MYID+1,10*II,pom_mpi_comm,STATUS,IERR)
   ELSEIF(MYRANK==0)THEN
   CALL MPI_SEND(ARR(ISLON,ISLAT+IND),ISIZE,MPI_REAL,MYID-1,10*II,pom_mpi_comm,IERR)
   ELSE
   CALL MPI_RECV(ARR(ISLON,IELAT+II),ISIZE,MPI_REAL,MYID+1,10*II,pom_mpi_comm,STATUS,IERR)
   CALL MPI_SEND(ARR(ISLON,ISLAT+IND),ISIZE,MPI_REAL,MYID-1,10*II,pom_mpi_comm,IERR)
   END IF
   END DO
   RETURN
   END SUBROUTINE UPDATE_2D_UP_BOTTOM
!  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   SUBROUTINE UPDATE_2D_LEFTBOTTOM_RIGHTUP(ARR,INDEX2)
   IMPLICIT NONE
   INTEGER II,INDEX2,IND,ISIZE
   REAL ARR(ISLON-LE:IELON+LE,ISLAT-LE:IELAT+LE),  &
        SBUF(INDEX2*INDEX2,4),RBUF(INDEX2*INDEX2,4)
   INTEGER IFLAG
   SBUF(:,:)=0
   RBUF(:,:)=0
   ISIZE=INDEX2*INDEX2
   DO I=0,INDEX2-1
   DO IND=0,INDEX2-1
   SBUF(I*INDEX2+IND+1,1)=ARR(ISLON+IND,ISLAT+I)
   SBUF(I*INDEX2+IND+1,2)=ARR(IELON-IND,ISLAT+I)
   SBUF(I*INDEX2+IND+1,3)=ARR(IELON-IND,IELAT-I)
   SBUF(I*INDEX2+IND+1,4)=ARR(ISLON+IND,IELAT-I)
   END DO
   END DO
   DO II=1,4
   IFLAG=NEIGHBOR(II)
   IF(IFLAG.NE.-1)THEN
!  FROM BOTTOM-LEFT CORNER TO UP-RIGHT CORNER
   IF(II.EQ.1)THEN
   CALL MPI_RECV(RBUF(1,II),ISIZE,MPI_REAL,IFLAG,MYID*10,pom_mpi_comm,STATUS,IERR)
   CALL MPI_SEND(SBUF(1,II),ISIZE,MPI_REAL,IFLAG,IFLAG*10,pom_mpi_comm,IERR)
   ELSEIF(II.EQ.3)THEN
   CALL MPI_SEND(SBUF(1,II),ISIZE,MPI_REAL,IFLAG,IFLAG*10,pom_mpi_comm,IERR)
   CALL MPI_RECV(RBUF(1,II),ISIZE,MPI_REAL,IFLAG,MYID*10,pom_mpi_comm,STATUS,IERR)
   END IF
!  FROM UP-LEFT CORNER TO BOTTOM-RIGHT CORNER
   IF(II.EQ.2)THEN
   CALL MPI_RECV(RBUF(1,II),ISIZE,MPI_REAL,IFLAG,MYID*10,pom_mpi_comm,STATUS,IERR)
   CALL MPI_SEND(SBUF(1,II),ISIZE,MPI_REAL,IFLAG,IFLAG*10,pom_mpi_comm,IERR)
   ELSEIF(II.EQ.4)THEN
   CALL MPI_SEND(SBUF(1,II),ISIZE,MPI_REAL,IFLAG,IFLAG*10,pom_mpi_comm,IERR)
   CALL MPI_RECV(RBUF(1,II),ISIZE,MPI_REAL,IFLAG,MYID*10,pom_mpi_comm,STATUS,IERR)
   END IF
   END IF
   END DO
   DO I=1,INDEX2
   DO IND=1,INDEX2
   ARR(ISLON-IND,ISLAT-I)=RBUF((I-1)*INDEX2+IND,1)
   ARR(IELON+IND,ISLAT-I)=RBUF((I-1)*INDEX2+IND,2)
   ARR(IELON+IND,IELAT+I)=RBUF((I-1)*INDEX2+IND,3)
   ARR(ISLON-IND,IELAT+I)=RBUF((I-1)*INDEX2+IND,4)
   END DO
   END DO
   RETURN
   END SUBROUTINE UPDATE_2D_LEFTBOTTOM_RIGHTUP
!  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   SUBROUTINE UPDATE_2D_LEFT_RIGHT(ARR,INDEX1)
   IMPLICIT NONE
   REAL ARR(ISLON-LE:IELON+LE,ISLAT-LE:IELAT+LE),       &
        SBUF(ISLAT:IELAT,3),RBUF(ISLAT:IELAT,3),        &
        SBUF1(ISLAT:IELAT,3),RBUF1(ISLAT:IELAT,3)
   INTEGER INDEX1,IND
   INTEGER MYRANK,ISIZE
   INTEGER KK,JJ
   
   MYRANK=MYID/NUMYCPU+1
   SBUF(:,:)=0.
   RBUF(:,:)=0.
   SBUF1(:,:)=0.
   RBUF1(:,:)=0.

   DO KK=1,INDEX1
   IND=KK-1
!!  FROM LEFT TO RIGHT
   ISIZE=IELAT-ISLAT+1

   DO JJ=ISLAT,IELAT
!   IF(IELON.NE.IM)SBUF(JJ,KK)=ARR(IELON-IND,JJ)
!   IF(ISLON.NE.1)SBUF1(JJ,KK)=ARR(ISLON+IND,JJ)
   SBUF(JJ,KK)=ARR(IELON-IND,JJ)
   SBUF1(JJ,KK)=ARR(ISLON+IND,JJ)
   END DO

!   IF(MYRANK==1)THEN
!   CALL MPI_SEND(SBUF(ISLAT,KK),ISIZE,MPI_REAL,MYID+NUMYCPU,100*KK,pom_mpi_comm,IERR)
!   ELSEIF(MYRANK==NUMXCPU)THEN
!   CALL MPI_RECV(RBUF(ISLAT,KK),ISIZE,MPI_REAL,MYID-NUMYCPU,100*KK,pom_mpi_comm,STATUS,IERR)
!   ELSE
!  CALL MPI_SEND(SBUF(ISLAT,KK),ISIZE,MPI_REAL,MYID+NUMYCPU,100*KK,pom_mpi_comm,IERR)
!  CALL MPI_RECV(RBUF(ISLAT,KK),ISIZE,MPI_REAL,MYID-NUMYCPU,100*KK,pom_mpi_comm,STATUS,IERR)
!   END IF
    CALL MPI_SENDRECV(SBUF(ISLAT,KK),ISIZE,MPI_REAL,IRIGHT,10000+kk,  &
                      RBUF(ISLAT,KK),ISIZE,MPI_REAL,ILEFT,10000+kk,pom_mpi_comm,STATUS,IERR)
!!  FROM RIGHT TO LEFT
  ! IF(MYRANK==1)THEN
  ! CALL MPI_RECV(RBUF1(ISLAT,KK),ISIZE,MPI_REAL,MYID+NUMYCPU,100*KK,pom_mpi_comm,STATUS,IERR)
  ! ELSEIF(MYRANK==NUMXCPU)THEN
  ! CALL MPI_SEND(SBUF1(ISLAT,KK),ISIZE,MPI_REAL,MYID-NUMYCPU,100*KK,pom_mpi_comm,IERR)
  ! ELSE
  ! CALL MPI_RECV(RBUF1(ISLAT,KK),ISIZE,MPI_REAL,MYID+NUMYCPU,100*KK,pom_mpi_comm,STATUS,IERR)
  ! CALL MPI_SEND(SBUF1(ISLAT,KK),ISIZE,MPI_REAL,MYID-NUMYCPU,100*KK,pom_mpi_comm,IERR)
  ! END IF
    CALL MPI_SENDRECV(SBUF1(ISLAT,KK),ISIZE,MPI_REAL,ILEFT,10000+kk,  &
                      RBUF1(ISLAT,KK),ISIZE,MPI_REAL,IRIGHT,10000+kk,pom_mpi_comm,STATUS,IERR)
   DO JJ=ISLAT,IELAT
!   IF(ISLON/=1)ARR(ISLON-KK,JJ)=RBUF(JJ,KK)
!   IF(IELON/=IM)ARR(IELON+KK,JJ)=RBUF1(JJ,KK)
   ARR(ISLON-KK,JJ)=RBUF(JJ,KK)
   ARR(IELON+KK,JJ)=RBUF1(JJ,KK)
   END DO
   END DO
   RETURN
   END SUBROUTINE UPDATE_2D_LEFT_RIGHT
!  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   SUBROUTINE COMM_3D(ARR,INDEX1,INDEX2)
   IMPLICIT NONE
   REAL ARR(ISLON-LE:IELON+LE,ISLAT-LE:IELAT+LE,KB)
   INTEGER INDEX1,INDEX2
   
   IF(NUMYCPU>1)CALL UPDATE_3D_UP_BOTTOM(ARR,INDEX1)
   IF(NUMXCPU>1)CALL UPDATE_3D_LEFT_RIGHT(ARR,INDEX2)
   IF(NUMYCPU>1.AND.NUMXCPU>1)CALL UPDATE_3D_LEFTBOTTOM_RIGHTUP(ARR,INDEX2)
   RETURN
   END SUBROUTINE COMM_3D
!  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   SUBROUTINE UPDATE_3D_UP_BOTTOM(ARR,INDEX1)
   IMPLICIT NONE

   REAL ARR(ISLON-LE:IELON+LE,ISLAT-LE:IELAT+LE,KB)
   REAL SBUF(ISLON:IELON,KB,3),RBUF(ISLON:IELON,KB,3),       &
        SBUF1(ISLON:IELON,KB,3),RBUF1(ISLON:IELON,KB,3)
   INTEGER INDEX1,IND
   INTEGER MYRANK,ISIZE
   INTEGER II,JJ,KK
   
   MYRANK=MOD(MYID+1,NUMYCPU)
   DO II=1,INDEX1
   IND=II-1
!  FROM BOTTOM TO UP EXCHANGE DATA
   ISIZE=(IELON-ISLON+1)*KB
   DO KK=1,KB
   DO JJ=ISLON,IELON
   IF(IELAT<JM) SBUF(JJ,KK,II)=ARR(JJ,IELAT-IND,KK)
   IF(ISLAT>1) SBUF1(JJ,KK,II)=ARR(JJ,ISLAT+IND,KK)
   END DO
   END DO
   IF(MYRANK==1)THEN
   CALL MPI_SEND(SBUF(ISLON,1,II),ISIZE,MPI_REAL,MYID+1,10*II,pom_mpi_comm,IERR)
   ELSEIF(MYRANK==0)THEN
   CALL MPI_RECV(RBUF(ISLON,1,II),ISIZE,MPI_REAL,MYID-1,10*II,pom_mpi_comm,STATUS,IERR)
   ELSE
   CALL MPI_SEND(SBUF(ISLON,1,II),ISIZE,MPI_REAL,MYID+1,10*II,pom_mpi_comm,IERR)
   CALL MPI_RECV(RBUF(ISLON,1,II),ISIZE,MPI_REAL,MYID-1,10*II,pom_mpi_comm,STATUS,IERR)
   END IF
!  FROM UP TO BOTTOM EXCHANGE DATA
   IF(MYRANK==1)THEN
   CALL MPI_RECV(RBUF1(ISLON,1,II),ISIZE,MPI_REAL,MYID+1,10*II,pom_mpi_comm,STATUS,IERR)
   ELSEIF(MYRANK==0)THEN
   CALL MPI_SEND(SBUF1(ISLON,1,II),ISIZE,MPI_REAL,MYID-1,10*II,pom_mpi_comm,IERR)
   ELSE
   CALL MPI_RECV(RBUF1(ISLON,1,II),ISIZE,MPI_REAL,MYID+1,10*II,pom_mpi_comm,STATUS,IERR)
   CALL MPI_SEND(SBUF1(ISLON,1,II),ISIZE,MPI_REAL,MYID-1,10*II,pom_mpi_comm,IERR)
   END IF
   
   DO KK=1,KB
   DO JJ=ISLON,IELON
   IF(ISLAT>1)ARR(JJ,ISLAT-II,KK)=RBUF(JJ,KK,II)
   IF(IELAT<JM)ARR(JJ,IELAT+II,KK)=RBUF1(JJ,KK,II)
   END DO
   END DO
   END DO
   RETURN
   END SUBROUTINE UPDATE_3D_UP_BOTTOM
!  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   SUBROUTINE UPDATE_3D_LEFTBOTTOM_RIGHTUP(ARR,INDEX2)
   IMPLICIT NONE
 
   INTEGER KK,II,INDEX2,IND,ISIZE
   REAL ARR(ISLON-LE:IELON+LE,ISLAT-LE:IELAT+LE,KB),         &
        SBUF(KB,INDEX2*INDEX2,4),RBUF(KB,INDEX2*INDEX2,4)
   INTEGER IFLAG
   
   SBUF(:,:,:)=0
   RBUF(:,:,:)=0
   ISIZE=INDEX2*INDEX2*KB
   
   DO I=0,INDEX2-1
   DO IND=0,INDEX2-1
   DO KK=1,KB
   SBUF(KK,I*INDEX2+IND+1,1)=ARR(ISLON+IND,ISLAT+I,KK)
   SBUF(KK,I*INDEX2+IND+1,2)=ARR(IELON-IND,ISLAT+I,KK)
   SBUF(KK,I*INDEX2+IND+1,3)=ARR(IELON-IND,IELAT-I,KK)
   SBUF(KK,I*INDEX2+IND+1,4)=ARR(ISLON+IND,IELAT-I,KK)
   END DO
   END DO
   END DO
   DO II=1,4
   IFLAG=NEIGHBOR(II)
   IF(IFLAG/=-1)THEN
!  FROM BOTTOM-LEFT CORNER TO UP-RIGHT CORNER
   IF(II==1)THEN
   CALL MPI_RECV(RBUF(1,1,II),ISIZE,MPI_REAL,IFLAG,MYID*10,pom_mpi_comm,STATUS,IERR)
   CALL MPI_SEND(SBUF(1,1,II),ISIZE,MPI_REAL,IFLAG,IFLAG*10,pom_mpi_comm,IERR)
   ELSEIF(II==3)THEN
   CALL MPI_SEND(SBUF(1,1,II),ISIZE,MPI_REAL,IFLAG,IFLAG*10,pom_mpi_comm,IERR)
   CALL MPI_RECV(RBUF(1,1,II),ISIZE,MPI_REAL,IFLAG,MYID*10,pom_mpi_comm,STATUS,IERR)
   END IF
!  FROM UP-LEFT CORNER TO BOTTOM-RIGHT CORNER
   IF(II==2)THEN
   CALL MPI_RECV(RBUF(1,1,II),ISIZE,MPI_REAL,IFLAG,MYID*10,pom_mpi_comm,STATUS,IERR)
   CALL MPI_SEND(SBUF(1,1,II),ISIZE,MPI_REAL,IFLAG,IFLAG*10,pom_mpi_comm,IERR)
   ELSEIF(II==4)THEN
   CALL MPI_SEND(SBUF(1,1,II),ISIZE,MPI_REAL,IFLAG,IFLAG*10,pom_mpi_comm,IERR)
   CALL MPI_RECV(RBUF(1,1,II),ISIZE,MPI_REAL,IFLAG,MYID*10,pom_mpi_comm,STATUS,IERR)
   END IF
   END IF
   END DO
   DO I=1,INDEX2
   DO IND=1,INDEX2
   DO KK=1,KB
   ARR(ISLON-IND,ISLAT-I,KK)=RBUF(KK,(I-1)*INDEX2+IND,1)
   ARR(IELON+IND,ISLAT-I,KK)=RBUF(KK,(I-1)*INDEX2+IND,2)
   ARR(IELON+IND,IELAT+I,KK)=RBUF(KK,(I-1)*INDEX2+IND,3)
   ARR(ISLON-IND,IELAT+I,KK)=RBUF(KK,(I-1)*INDEX2+IND,4)
   END DO
   END DO
   END DO
   RETURN
   END SUBROUTINE UPDATE_3D_LEFTBOTTOM_RIGHTUP
!  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   SUBROUTINE UPDATE_3D_LEFT_RIGHT(ARR,INDEX1)
   IMPLICIT NONE

   REAL ARR(ISLON-LE:IELON+LE,ISLAT-LE:IELAT+LE,KB),    &
        SBUF(ISLAT:IELAT,KB,3),RBUF(ISLAT:IELAT,KB,3),  &
        SBUF1(ISLAT:IELAT,KB,3),RBUF1(ISLAT:IELAT,KB,3)
   INTEGER INDEX1,IND
   INTEGER MYRANK,ISIZE
   INTEGER II,JJ,KK

   MYRANK=MYID/NUMYCPU+1
   SBUF(:,:,:)=0.
   RBUF(:,:,:)=0.
   SBUF1(:,:,:)=0.
   RBUF1(:,:,:)=0.

   DO KK=1,INDEX1
     IND=KK-1
!  FROM LEFT TO RIGHT
   ISIZE=(IELAT-ISLAT+1)*KB
   DO II=1,KB
   DO JJ=ISLAT,IELAT
      !!IF(IELON.NE.IM)SBUF(JJ,II,KK)=ARR(IELON-IND,JJ,II)
      !!IF(ISLON.NE.1)SBUF1(JJ,II,KK)=ARR(ISLON+IND,JJ,II)
      SBUF(JJ,II,KK)=ARR(IELON-IND,JJ,II)
      SBUF1(JJ,II,KK)=ARR(ISLON+IND,JJ,II)
   END DO
   END DO

!   IF(MYRANK==1)THEN
!   CALL MPI_SEND(SBUF(ISLAT,1,KK),ISIZE,MPI_REAL,MYID+NUMYCPU,100*KK,pom_mpi_comm,IERR)
!   ELSEIF(MYRANK==NUMXCPU)THEN
!   CALL MPI_RECV(RBUF(ISLAT,1,KK),ISIZE,MPI_REAL,MYID-NUMYCPU,100*KK,pom_mpi_comm,STATUS,IERR)
!   ELSE
!   CALL MPI_SEND(SBUF(ISLAT,1,KK),ISIZE,MPI_REAL,MYID+NUMYCPU,100*KK,pom_mpi_comm,IERR)
!   CALL MPI_RECV(RBUF(ISLAT,1,KK),ISIZE,MPI_REAL,MYID-NUMYCPU,100*KK,pom_mpi_comm,STATUS,IERR)
!   END IF
    CALL MPI_SENDRECV(SBUF(ISLAT,1,KK),ISIZE,MPI_REAL,IRIGHT,10000+kk,     &
                      RBUF(ISLAT,1,KK),ISIZE,MPI_REAL,ILEFT,10000+kk,pom_mpi_comm,STATUS,IERR)
!  FROM RIGHT TO LEFT
!   IF(MYRANK==1)THEN
!   CALL MPI_RECV(RBUF1(ISLAT,1,KK),ISIZE,MPI_REAL,MYID+NUMYCPU,100*KK,pom_mpi_comm,STATUS,IERR)
!   ELSEIF(MYRANK==NUMXCPU)THEN
!   CALL MPI_SEND(SBUF1(ISLAT,1,KK),ISIZE,MPI_REAL,MYID-NUMYCPU,100*KK,pom_mpi_comm,IERR)
!   ELSE
!   CALL MPI_RECV(RBUF1(ISLAT,1,KK),ISIZE,MPI_REAL,MYID+NUMYCPU,100*KK,pom_mpi_comm,STATUS,IERR)
!   CALL MPI_SEND(SBUF1(ISLAT,1,KK),ISIZE,MPI_REAL,MYID-NUMYCPU,100*KK,pom_mpi_comm,IERR)
 !  END IF
    CALL MPI_SENDRECV(SBUF1(ISLAT,1,KK),ISIZE,MPI_REAL,ILEFT,10000+kk,  &
                     RBUF1(ISLAT,1,KK),ISIZE,MPI_REAL,IRIGHT,10000+kk,pom_mpi_comm,STATUS,IERR)
   DO II=1,KB
   DO JJ=ISLAT,IELAT
   !IF(ISLON.NE.1)ARR(ISLON-KK,JJ,II)=RBUF(JJ,II,KK)
   !IF(IELON.NE.IM)ARR(IELON+KK,JJ,II)=RBUF1(JJ,II,KK)
   ARR(ISLON-KK,JJ,II)=RBUF(JJ,II,KK)
   ARR(IELON+KK,JJ,II)=RBUF1(JJ,II,KK)
   END DO
   END DO
   END DO
   RETURN
   END SUBROUTINE UPDATE_3D_LEFT_RIGHT
!  >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
   SUBROUTINE COMM_INTERNAL_MODE
!  FOR 3 DIMENISON
      CALL COMM_3D(U,2,2)
      CALL COMM_3D(V,2,2)
      CALL COMM_3D(UB,2,2)
      CALL COMM_3D(VB,2,2)
      CALL COMM_3D(RHO,1,1)
      CALL COMM_3D(Q2,2,2)
      CALL COMM_3D(Q2B,2,2)
      CALL COMM_3D(Q2LB,2,2)
      CALL COMM_3D(Q2L,2,2)
      CALL COMM_3D(T,2,2)
      CALL COMM_3D(TB,2,2)
      CALL COMM_3D(S,2,2)
      CALL COMM_3D(SB,2,2)
      CALL COMM_3D(AAM,2,2)
!  FOR 2 DIMENSION
      CALL COMM_2D(DT,3,3)
      CALL COMM_2D(D,3,3)
      CALL COMM_2D(UA,2,2)
      CALL COMM_2D(VA,2,2)
      CALL COMM_2D(UAB,2,2)
      CALL COMM_2D(VAB,2,2)
      CALL COMM_2D(EGB,1,1)
      CALL COMM_2D(ETB,1,1)
      CALL COMM_2D(WUSURF,3,3)
      CALL COMM_2D(WVSURF,3,3)
      CALL COMM_2D(WUBOT,1,1)
      CALL COMM_2D(WVBOT,1,1)
   END SUBROUTINE COMM_INTERNAL_MODE
!************************************************************************
   SUBROUTINE COMM_EXTERNAL_MODE
      CALL COMM_2D(UA,2,2) 
      CALL COMM_2D(VA,2,2) 
      CALL COMM_2D(UAB,2,2)
      CALL COMM_2D(VAB,2,2)
      CALL COMM_2D(D,3,3)  
      CALL COMM_2D(EL,1,1) 
      CALL COMM_2D(ELB,1,1)
   END SUBROUTINE COMM_EXTERNAL_MODE
!************************************************************************
  SUBROUTINE COMPTEST(H,LL)
   IMPLICIT NONE
   INTEGER,INTENT(in) :: LL
   REAL(kind_r4),DIMENSION(ISLON-LE:IELON+LE,ISLAT-LE:IELAT+LE) :: H

   INTEGER UNITS,I,K,HALOID
   REAL B(LL),O(LL)
   CHARACTER*100 InFile
   REAL(kind_r4) :: ZERO

   IF(KIND_R4==4)ZERO=1.E-6
   IF(KIND_R4==8)ZERO=1.E-14
!  =================================================
!   WRITE TEST DATA
!   UPPER
   IF(Iup>=0)THEN
   UNITS=4000+Iup
   INFILE='boud.XXXX'
   WRITE(INFILE(6:9),'(I4.4)')UNITS
   OPEN(UNITS,FILE=INFILE,STATUS='unknown')
   DO K=ISLON,IELON
   WRITE(UNITS,'(<LL>f15.6)')H(K,IELAT-LL+1:IELAT)
   END DO
   CLOSE(UNITS)
   END IF
!   DOWN
   IF(Idown>=0)THEN
   UNITS=3000+Idown
   INFILE='boud.XXXX'
   WRITE(INFILE(6:9),'(I4.4)')UNITS
   OPEN(UNITS,FILE=INFILE,STATUS='unknown')
   DO K=ISLON,IELON
   WRITE(UNITS,'(<LL>f15.6)')H(K,ISLAT:ISLAT+LL-1)
   END DO
   CLOSE(UNITS)
   END IF
   CALL BARRIER
!  ++++++++++++++++++++++++++++++++++++++++++++++
!  check up-lower bounday
   IF(IUP>=0)THEN
   INFILE='boud.XXXX'
   WRITE(INFILE(6:9),'(I4.4)')3000+MYID
   OPEN(110,file=INFILE,status='old')
   DO K=ISLON,IELON
   READ(110,'(<LL>f15.6)')B
   O=H(K,IELAT+1:IELAT+LL)
   DO I=1,LL
   IF(ABS(B(I)-O(I))>ZERO)THEN
   WRITE(6,'(3I,2f)')K,IElAT+I,I,B(I),O(I)
   CALL PAR_END
   END IF
   END DO
   END DO
   CLOSE(110,status='delete')
   END IF
   CALL BARRIER
   WRITE(6,*)"UPPER BOUNDARY IS CONSIST WITH THE NEIGHBOR"

  IF(IDOWN>=0)THEN
!   compare lower boundary
   INFILE='boud.XXXX'
   WRITE(INFILE(6:9),'(I4.4)')4000+MYID
   OPEN(110,file=INFILE,status='old')
   DO K=ISLON,IELON
   READ(110,'(<LL>f15.6)')B
   O=H(K,ISLAT-LL:ISLAT-1)
   DO I=1,LL
   IF(ABS(B(I)-O(I))>ZERO)THEN
   WRITE(6,'(3I,2f)')K,IElAT+I,I,B(I),O(I)
   CALL PAR_END
   END IF
   END DO
   END DO
   CLOSE(110,status='delete')
   END IF
   CALL BARRIER
   WRITE(6,*)"LOWER BOUNDARY IS CONSIST WITH THE NEIGHBOR"
!  =================================================
!   LEFT
   IF(Ileft>=0)THEN
   UNITS=1000+Ileft
   INFILE='boud.XXXX.XXX'
   WRITE(INFILE(6:9),'(I4.4)')UNITS
   WRITE(INFILE(11:13),'(I3.3)')MYID
   OPEN(UNITS,FILE=INFILE,STATUS='unknown',POSITION='append')
   DO K=ISLAT,IELAT
    WRITE(UNITS,'(<LL>f15.6,1x,I)')H(ISLON:ISLON+LL-1,K),ILEFT
   END DO
   CLOSE(UNITS)
   END IF
!   RIGHT
   IF(Iright>=0)THEN
   UNITS=2000+Iright
   INFILE='boud.XXXX.XXX'
   WRITE(INFILE(6:9),'(I4.4)')UNITS
   WRITE(INFILE(11:13),'(I3.3)')MYID
   OPEN(UNITS,FILE=INFILE,STATUS='unknown',POSITION='append')
   DO K=ISLAT,IELAT
   WRITE(UNITS,'(<LL>f15.6,1x,I)')H(IELON-LL+1:IELON,K),IRIGHT
   END DO
   CLOSE(UNITS)
   END IF
   CALL BARRIER
!  ++++++++++++++++++++++++++++++++++++++++++++++
!  check left right boundar data
   IF(IRIGHT>=0)THEN
!   compare right boundary
   INFILE='boud.XXXX.XXX'
   WRITE(INFILE(6:9),'(I4.4)')1000+MYID
   WRITE(INFILE(11:13),'(I3.3)')IRIGHT
!   PRINT*,MYID,"READ RIGHT BOUDARY ",TRIM(INFILE),IRIGHT
   OPEN(110,file=INFILE,status='old')

   DO K=ISLAT,IELAT

   READ(110,'(<LL>f15.6,I)')B,HALOID
   O=H(IELON+1:IELON+LL,K)
   DO I=1,LL
   IF(ABS(B(I)-O(I))>ZERO)THEN
   WRITE(6,'(5I,2f)')MYID,IRIGHT,K,IElAT+I,I,B(I),O(I)
   CALL PAR_END
   END IF
   END DO
   END DO
   CLOSE(110,status='delete')
   END IF
   CALL BARRIER
   WRITE(6,*)"RIGHT BOUNDARY IS CONSIST WITH THE NEIGHBOR"

  IF(Ileft>=0)THEN
!   compare left boundary
   INFILE='boud.XXXX.XXX'
   WRITE(INFILE(6:9),'(I4.4)')2000+MYID
   WRITE(INFILE(11:13),'(I3.3)')ILefT
   OPEN(110,file=INFILE,status='old')

   DO K=ISLAT,IELAT
   READ(110,'(<LL>f15.6,i)')B,HALOID
   O=H(ISLON-LL:ISLON-1,K)
   DO I=1,LL
   IF(ABS(B(I)-O(I))>ZERO)THEN
   WRITE(6,'(3I,2f)')K,IElAT+I,I,B(I),O(I)
   CALL PAR_END
   END IF
   END DO
   END DO
   CLOSE(110,status='delete')
   END IF
   CALL BARRIER
   WRITE(6,*)"LEFT BOUNDARY IS CONSIST WITH THE NEIGHBOR"
!  =================================================
!   UPPER-LEFT
   !!IF(NUM_CORNER_SEND/=MPI_PROC_NULL)THEN
  DO K=1,4 !NUM_CORNER_SEND
   IF(NEIGHBOR(K)>=0)THEN
   INFILE='boud.XXX.XX'
   WRITE(INFILE,'(a5,i3.3,a1,i2.2)')'boud.',NEIGHBOR(K),'.',mod(K+2,4)
   !PRINT*,MYID,NEIGHBOR(K),K,TRIM(INFILE)
   OPEN(UNITS,FILE=INFILE,STATUS='unknown')
   DO I=1,LL
    IF(K==1)WRITE(UNITS,'(<LL>f15.6)')H(NEIGHBOR_ID(1,K):NEIGHBOR_ID(1,K)+LL-1,NEIGHBOR_ID(2,K)+I-1)
    IF(K==2)WRITE(UNITS,'(<LL>f15.6)')H(NEIGHBOR_ID(1,K)-LL+1:NEIGHBOR_ID(1,K),NEIGHBOR_ID(2,K)+I-1)
    IF(K==3)WRITE(UNITS,'(<LL>f15.6)')H(NEIGHBOR_ID(1,K)-LL+1:NEIGHBOR_ID(1,K),NEIGHBOR_ID(2,K)-I+1)
    IF(K==4)WRITE(UNITS,'(<LL>f15.6)')H(NEIGHBOR_ID(1,K):NEIGHBOR_ID(1,K)+LL-1,NEIGHBOR_ID(2,K)-I+1)
   END DO
   CLOSE(UNITS)
   END IF
  END DO
  CALL BARRIER
!   FOR CENTER SUB-DOMAIN AND COMPARING THE ARIFICAL
   IF(NEIGHBOR(4)>=0)THEN
!   compare upleft boundary
   WRITE(INFILE,'(a5,i3.3,a1,i2.2)')'boud.',MYID,'.',0
   OPEN(110,file=INFILE,status='old')
   DO I=1,LL
   READ(110,'(<LL>f15.6)')B
   O=H(NEIGHBOR_ID(1,4)-LL:NEIGHBOR_ID(1,4)-1,NEIGHBOR_ID(2,4)+I)
   DO J=1,LL
   IF(ABS(B(J)-O(J))>ZERO)THEN
   WRITE(6,'(5I,2f)')MYID,ISLON-J,IElAT+I,I,J,B(J),O(J)
   CALL PAR_END
   END IF
   END DO
   END DO
   CLOSE(110,status='delete')
   END IF
   CALL BARRIER
   WRITE(6,*)"UPLEFT BOUNDARY IS CONSIST WITH THE NEIGHBOR"

   IF(NEIGHBOR(3)>=0)THEN
!   compare upright boundary
   WRITE(INFILE,'(a5,i3.3,a1,i2.2)')'boud.',MYID,'.',3
   OPEN(110,file=INFILE,status='old')
   DO I=1,LL
   READ(110,'(<LL>f15.6)')B
   O=H(NEIGHBOR_ID(1,3)+1:NEIGHBOR_ID(1,3)+LL,NEIGHBOR_ID(2,3)+I)
   DO J=1,LL
   IF(ABS(B(J)-O(J))>ZERO)THEN
   WRITE(6,'(5I,2f)')MYID,IELON+J,IElAT+I,I,J,B(J),O(J)
   CALL PAR_END
   END IF
   END DO
   END DO
   CLOSE(110,status='delete')
   END IF
   CALL BARRIER
   WRITE(6,*)"UPRIGHT BOUNDARY IS CONSIST WITH THE NEIGHBOR"


   IF(NEIGHBOR(2)>=0)THEN
!   compare lowerright boundary
   WRITE(INFILE,'(a5,i3.3,a1,i2.2)')'boud.',MYID,'.',2
   OPEN(110,file=INFILE,status='old')
   DO I=1,LL
   READ(110,'(<LL>f15.6)')B
   O=H(NEIGHBOR_ID(1,2)+1:NEIGHBOR_ID(1,2)+LL,NEIGHBOR_ID(2,2)-I)
   DO J=1,LL
   IF(ABS(B(J)-O(J))>ZERO)THEN
   WRITE(6,'(5I,2f)')MYID,IELON+J,ISlAT-I,I,J,B(J),O(J)
   CALL PAR_END
   END IF
   END DO
   END DO
   CLOSE(110,status='delete')
   END IF
   CALL BARRIER
   WRITE(6,*)"LOWERRIGHT BOUNDARY IS CONSIST WITH THE NEIGHBOR"

   IF(NEIGHBOR(1)>=0)THEN
!   compare lowerleft boundary
   WRITE(INFILE,'(a5,i3.3,a1,i2.2)')'boud.',MYID,'.',1
   OPEN(110,file=INFILE,status='old')
   DO I=1,LL
   READ(110,'(<LL>f15.6)')B
   O=H(NEIGHBOR_ID(1,1)-LL:NEIGHBOR_ID(1,1)-1,NEIGHBOR_ID(2,1)-I)
   DO J=1,LL
   IF(ABS(B(J)-O(J))>ZERO)THEN
   WRITE(6,'(5I,2f)')MYID,ISLON-J,ISlAT-I,I,J,B(J),O(J)
   CALL PAR_END
   END IF
   END DO
   END DO
   CLOSE(110,status='delete')
   END IF
   CALL BARRIER
   WRITE(6,*)"LOWERLEFT BOUNDARY IS CONSIST WITH THE NEIGHBOR"
   RETURN
   END SUBROUTINE COMPTEST
 
END MODULE PARALLEL_MOD
